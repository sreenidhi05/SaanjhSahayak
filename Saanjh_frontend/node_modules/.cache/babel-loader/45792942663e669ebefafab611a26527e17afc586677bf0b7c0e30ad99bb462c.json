{"ast":null,"code":"/// <reference path=\"./index.d.ts\" />\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\n// src/tasks/index.ts\nvar tasks_exports = {};\n__export(tasks_exports, {\n  audioClassification: () => audioClassification,\n  audioToAudio: () => audioToAudio,\n  automaticSpeechRecognition: () => automaticSpeechRecognition,\n  documentQuestionAnswering: () => documentQuestionAnswering,\n  featureExtraction: () => featureExtraction,\n  fillMask: () => fillMask,\n  imageClassification: () => imageClassification,\n  imageSegmentation: () => imageSegmentation,\n  imageToImage: () => imageToImage,\n  imageToText: () => imageToText,\n  objectDetection: () => objectDetection,\n  questionAnswering: () => questionAnswering,\n  request: () => request,\n  sentenceSimilarity: () => sentenceSimilarity,\n  streamingRequest: () => streamingRequest,\n  summarization: () => summarization,\n  tableQuestionAnswering: () => tableQuestionAnswering,\n  tabularClassification: () => tabularClassification,\n  tabularRegression: () => tabularRegression,\n  textClassification: () => textClassification,\n  textGeneration: () => textGeneration,\n  textGenerationStream: () => textGenerationStream,\n  textToImage: () => textToImage,\n  textToSpeech: () => textToSpeech,\n  tokenClassification: () => tokenClassification,\n  translation: () => translation,\n  visualQuestionAnswering: () => visualQuestionAnswering,\n  zeroShotClassification: () => zeroShotClassification,\n  zeroShotImageClassification: () => zeroShotImageClassification\n});\n\n// src/lib/isUrl.ts\nfunction isUrl(modelOrUrl) {\n  return /^http(s?):/.test(modelOrUrl) || modelOrUrl.startsWith(\"/\");\n}\n\n// src/lib/getDefaultTask.ts\nvar taskCache = /* @__PURE__ */new Map();\nvar CACHE_DURATION = 10 * 60 * 1e3;\nvar MAX_CACHE_ITEMS = 1e3;\nvar HF_HUB_URL = \"https://huggingface.co\";\nasync function getDefaultTask(model, accessToken, options) {\n  if (isUrl(model)) {\n    return null;\n  }\n  const key = `${model}:${accessToken}`;\n  let cachedTask = taskCache.get(key);\n  if (cachedTask && cachedTask.date < new Date(Date.now() - CACHE_DURATION)) {\n    taskCache.delete(key);\n    cachedTask = void 0;\n  }\n  if (cachedTask === void 0) {\n    const modelTask = await (options?.fetch ?? fetch)(`${HF_HUB_URL}/api/models/${model}?expand[]=pipeline_tag`, {\n      headers: accessToken ? {\n        Authorization: `Bearer ${accessToken}`\n      } : {}\n    }).then(resp => resp.json()).then(json => json.pipeline_tag).catch(() => null);\n    if (!modelTask) {\n      return null;\n    }\n    cachedTask = {\n      task: modelTask,\n      date: /* @__PURE__ */new Date()\n    };\n    taskCache.set(key, {\n      task: modelTask,\n      date: /* @__PURE__ */new Date()\n    });\n    if (taskCache.size > MAX_CACHE_ITEMS) {\n      taskCache.delete(taskCache.keys().next().value);\n    }\n  }\n  return cachedTask.task;\n}\n\n// src/lib/makeRequestOptions.ts\nvar HF_INFERENCE_API_BASE_URL = \"https://api-inference.huggingface.co\";\nvar tasks = null;\nasync function makeRequestOptions(args, options) {\n  const {\n    accessToken,\n    model: _model,\n    ...otherArgs\n  } = args;\n  let {\n    model\n  } = args;\n  const {\n    forceTask: task,\n    includeCredentials,\n    taskHint,\n    wait_for_model,\n    use_cache,\n    dont_load_model,\n    ...otherOptions\n  } = options ?? {};\n  const headers = {};\n  if (accessToken) {\n    headers[\"Authorization\"] = `Bearer ${accessToken}`;\n  }\n  if (!model && !tasks && taskHint) {\n    const res = await fetch(`${HF_HUB_URL}/api/tasks`);\n    if (res.ok) {\n      tasks = await res.json();\n    }\n  }\n  if (!model && tasks && taskHint) {\n    const taskInfo = tasks[taskHint];\n    if (taskInfo) {\n      model = taskInfo.models[0].id;\n    }\n  }\n  if (!model) {\n    throw new Error(\"No model provided, and no default model found for this task\");\n  }\n  const binary = \"data\" in args && !!args.data;\n  if (!binary) {\n    headers[\"Content-Type\"] = \"application/json\";\n  }\n  if (wait_for_model) {\n    headers[\"X-Wait-For-Model\"] = \"true\";\n  }\n  if (use_cache === false) {\n    headers[\"X-Use-Cache\"] = \"false\";\n  }\n  if (dont_load_model) {\n    headers[\"X-Load-Model\"] = \"0\";\n  }\n  const url = (() => {\n    if (isUrl(model)) {\n      return model;\n    }\n    if (task) {\n      return `${HF_INFERENCE_API_BASE_URL}/pipeline/${task}/${model}`;\n    }\n    return `${HF_INFERENCE_API_BASE_URL}/models/${model}`;\n  })();\n  let credentials;\n  if (typeof includeCredentials === \"string\") {\n    credentials = includeCredentials;\n  } else if (includeCredentials === true) {\n    credentials = \"include\";\n  }\n  const info = {\n    headers,\n    method: \"POST\",\n    body: binary ? args.data : JSON.stringify({\n      ...otherArgs,\n      options: options && otherOptions\n    }),\n    ...(credentials && {\n      credentials\n    }),\n    signal: options?.signal\n  };\n  return {\n    url,\n    info\n  };\n}\n\n// src/tasks/custom/request.ts\nasync function request(args, options) {\n  const {\n    url,\n    info\n  } = await makeRequestOptions(args, options);\n  const response = await (options?.fetch ?? fetch)(url, info);\n  if (options?.retry_on_error !== false && response.status === 503 && !options?.wait_for_model) {\n    return request(args, {\n      ...options,\n      wait_for_model: true\n    });\n  }\n  if (!response.ok) {\n    if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n      const output = await response.json();\n      if (output.error) {\n        throw new Error(output.error);\n      }\n    }\n    throw new Error(\"An error occurred while fetching the blob\");\n  }\n  if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n    return await response.json();\n  }\n  return await response.blob();\n}\n\n// src/vendor/fetch-event-source/parse.ts\nfunction getLines(onLine) {\n  let buffer;\n  let position;\n  let fieldLength;\n  let discardTrailingNewline = false;\n  return function onChunk(arr) {\n    if (buffer === void 0) {\n      buffer = arr;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      buffer = concat(buffer, arr);\n    }\n    const bufLength = buffer.length;\n    let lineStart = 0;\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10 /* NewLine */) {\n          lineStart = ++position;\n        }\n        discardTrailingNewline = false;\n      }\n      let lineEnd = -1;\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58 /* Colon */:\n            if (fieldLength === -1) {\n              fieldLength = position - lineStart;\n            }\n            break;\n          case 13 /* CarriageReturn */:\n            discardTrailingNewline = true;\n          case 10 /* NewLine */:\n            lineEnd = position;\n            break;\n        }\n      }\n      if (lineEnd === -1) {\n        break;\n      }\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n      lineStart = position;\n      fieldLength = -1;\n    }\n    if (lineStart === bufLength) {\n      buffer = void 0;\n    } else if (lineStart !== 0) {\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\nfunction getMessages(onId, onRetry, onMessage) {\n  let message = newMessage();\n  const decoder = new TextDecoder();\n  return function onLine(line, fieldLength) {\n    if (line.length === 0) {\n      onMessage?.(message);\n      message = newMessage();\n    } else if (fieldLength > 0) {\n      const field = decoder.decode(line.subarray(0, fieldLength));\n      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* Space */ ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n      switch (field) {\n        case \"data\":\n          message.data = message.data ? message.data + \"\\n\" + value : value;\n          break;\n        case \"event\":\n          message.event = value;\n          break;\n        case \"id\":\n          onId(message.id = value);\n          break;\n        case \"retry\":\n          const retry = parseInt(value, 10);\n          if (!isNaN(retry)) {\n            onRetry(message.retry = retry);\n          }\n          break;\n      }\n    }\n  };\n}\nfunction concat(a, b) {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\nfunction newMessage() {\n  return {\n    data: \"\",\n    event: \"\",\n    id: \"\",\n    retry: void 0\n  };\n}\n\n// src/tasks/custom/streamingRequest.ts\nasync function* streamingRequest(args, options) {\n  const {\n    url,\n    info\n  } = await makeRequestOptions({\n    ...args,\n    stream: true\n  }, options);\n  const response = await (options?.fetch ?? fetch)(url, info);\n  if (options?.retry_on_error !== false && response.status === 503 && !options?.wait_for_model) {\n    return yield* streamingRequest(args, {\n      ...options,\n      wait_for_model: true\n    });\n  }\n  if (!response.ok) {\n    if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n      const output = await response.json();\n      if (output.error) {\n        throw new Error(output.error);\n      }\n    }\n    throw new Error(`Server response contains error: ${response.status}`);\n  }\n  if (!response.headers.get(\"content-type\")?.startsWith(\"text/event-stream\")) {\n    throw new Error(`Server does not support event stream content type, it returned ` + response.headers.get(\"content-type\"));\n  }\n  if (!response.body) {\n    return;\n  }\n  const reader = response.body.getReader();\n  let events = [];\n  const onEvent = event => {\n    events.push(event);\n  };\n  const onChunk = getLines(getMessages(() => {}, () => {}, onEvent));\n  try {\n    while (true) {\n      const {\n        done,\n        value\n      } = await reader.read();\n      if (done) return;\n      onChunk(value);\n      for (const event of events) {\n        if (event.data.length > 0) {\n          const data = JSON.parse(event.data);\n          if (typeof data === \"object\" && data !== null && \"error\" in data) {\n            throw new Error(data.error);\n          }\n          yield data;\n        }\n      }\n      events = [];\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n// src/lib/InferenceOutputError.ts\nvar InferenceOutputError = class extends TypeError {\n  constructor(message) {\n    super(`Invalid inference output: ${message}. Use the 'request' method with the same parameters to do a custom call with no type checking.`);\n    this.name = \"InferenceOutputError\";\n  }\n};\n\n// src/tasks/audio/audioClassification.ts\nasync function audioClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"audio-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/audio/automaticSpeechRecognition.ts\nasync function automaticSpeechRecognition(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"automatic-speech-recognition\"\n  });\n  const isValidOutput = typeof res?.text === \"string\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {text: string}\");\n  }\n  return res;\n}\n\n// src/tasks/audio/textToSpeech.ts\nasync function textToSpeech(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-to-speech\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/tasks/audio/audioToAudio.ts\nasync function audioToAudio(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"audio-to-audio\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.blob === \"string\" && typeof x[\"content-type\"] === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, blob: string, content-type: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageClassification.ts\nasync function imageClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"image-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageSegmentation.ts\nasync function imageSegmentation(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"image-segmentation\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.mask === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, mask: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageToText.ts\nasync function imageToText(args, options) {\n  const res = (await request(args, {\n    ...options,\n    taskHint: \"image-to-text\"\n  }))?.[0];\n  if (typeof res?.generated_text !== \"string\") {\n    throw new InferenceOutputError(\"Expected {generated_text: string}\");\n  }\n  return res;\n}\n\n// src/tasks/cv/objectDetection.ts\nasync function objectDetection(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"object-detection\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.score === \"number\" && typeof x.box.xmin === \"number\" && typeof x.box.ymin === \"number\" && typeof x.box.xmax === \"number\" && typeof x.box.ymax === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label:string; score:number; box:{xmin:number; ymin:number; xmax:number; ymax:number}}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/textToImage.ts\nasync function textToImage(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-to-image\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// ../shared/src/base64FromBytes.ts\nfunction base64FromBytes(arr) {\n  if (globalThis.Buffer) {\n    return globalThis.Buffer.from(arr).toString(\"base64\");\n  } else {\n    const bin = [];\n    arr.forEach(byte => {\n      bin.push(String.fromCharCode(byte));\n    });\n    return globalThis.btoa(bin.join(\"\"));\n  }\n}\n\n// ../shared/src/isBackend.ts\nvar isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\nvar isWebWorker = typeof self === \"object\" && self.constructor && self.constructor.name === \"DedicatedWorkerGlobalScope\";\n\n// src/tasks/cv/imageToImage.ts\nasync function imageToImage(args, options) {\n  let reqArgs;\n  if (!args.parameters) {\n    reqArgs = {\n      accessToken: args.accessToken,\n      model: args.model,\n      data: args.inputs\n    };\n  } else {\n    reqArgs = {\n      ...args,\n      inputs: base64FromBytes(new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer()))\n    };\n  }\n  const res = await request(reqArgs, {\n    ...options,\n    taskHint: \"image-to-image\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/tasks/cv/zeroShotImageClassification.ts\nasync function zeroShotImageClassification(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      image: base64FromBytes(new Uint8Array(args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()))\n    }\n  };\n  const res = await request(reqArgs, {\n    ...options,\n    taskHint: \"zero-shot-image-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/featureExtraction.ts\nasync function featureExtraction(args, options) {\n  const defaultTask = args.model ? await getDefaultTask(args.model, args.accessToken, options) : void 0;\n  const res = await request(args, {\n    ...options,\n    taskHint: \"feature-extraction\",\n    ...(defaultTask === \"sentence-similarity\" && {\n      forceTask: \"feature-extraction\"\n    })\n  });\n  let isValidOutput = true;\n  const isNumArrayRec = (arr, maxDepth, curDepth = 0) => {\n    if (curDepth > maxDepth) return false;\n    if (arr.every(x => Array.isArray(x))) {\n      return arr.every(x => isNumArrayRec(x, maxDepth, curDepth + 1));\n    } else {\n      return arr.every(x => typeof x === \"number\");\n    }\n  };\n  isValidOutput = Array.isArray(res) && isNumArrayRec(res, 3, 0);\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<number[][][] | number[][] | number[] | number>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/fillMask.ts\nasync function fillMask(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"fill-mask\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.score === \"number\" && typeof x.sequence === \"string\" && typeof x.token === \"number\" && typeof x.token_str === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{score: number, sequence: string, token: number, token_str: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/questionAnswering.ts\nasync function questionAnswering(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"question-answering\"\n  });\n  const isValidOutput = typeof res === \"object\" && !!res && typeof res.answer === \"string\" && typeof res.end === \"number\" && typeof res.score === \"number\" && typeof res.start === \"number\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {answer: string, end: number, score: number, start: number}\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/sentenceSimilarity.ts\nasync function sentenceSimilarity(args, options) {\n  const defaultTask = args.model ? await getDefaultTask(args.model, args.accessToken, options) : void 0;\n  const res = await request(args, {\n    ...options,\n    taskHint: \"sentence-similarity\",\n    ...(defaultTask === \"feature-extraction\" && {\n      forceTask: \"sentence-similarity\"\n    })\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/summarization.ts\nasync function summarization(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"summarization\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x?.summary_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{summary_text: string}>\");\n  }\n  return res?.[0];\n}\n\n// src/tasks/nlp/tableQuestionAnswering.ts\nasync function tableQuestionAnswering(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"table-question-answering\"\n  });\n  const isValidOutput = typeof res?.aggregator === \"string\" && typeof res.answer === \"string\" && Array.isArray(res.cells) && res.cells.every(x => typeof x === \"string\") && Array.isArray(res.coordinates) && res.coordinates.every(coord => Array.isArray(coord) && coord.every(x => typeof x === \"number\"));\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {aggregator: string, answer: string, cells: string[], coordinates: number[][]}\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/textClassification.ts\nasync function textClassification(args, options) {\n  const res = (await request(args, {\n    ...options,\n    taskHint: \"text-classification\"\n  }))?.[0];\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x?.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/textGeneration.ts\nasync function textGeneration(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-generation\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x?.generated_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{generated_text: string}>\");\n  }\n  return res?.[0];\n}\n\n// src/tasks/nlp/textGenerationStream.ts\nasync function* textGenerationStream(args, options) {\n  yield* streamingRequest(args, {\n    ...options,\n    taskHint: \"text-generation\"\n  });\n}\n\n// src/utils/toArray.ts\nfunction toArray(obj) {\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return [obj];\n}\n\n// src/tasks/nlp/tokenClassification.ts\nasync function tokenClassification(args, options) {\n  const res = toArray(await request(args, {\n    ...options,\n    taskHint: \"token-classification\"\n  }));\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.end === \"number\" && typeof x.entity_group === \"string\" && typeof x.score === \"number\" && typeof x.start === \"number\" && typeof x.word === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{end: number, entity_group: string, score: number, start: number, word: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/translation.ts\nasync function translation(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"translation\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x?.translation_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected type Array<{translation_text: string}>\");\n  }\n  return res?.length === 1 ? res?.[0] : res;\n}\n\n// src/tasks/nlp/zeroShotClassification.ts\nasync function zeroShotClassification(args, options) {\n  const res = toArray(await request(args, {\n    ...options,\n    taskHint: \"zero-shot-classification\"\n  }));\n  const isValidOutput = Array.isArray(res) && res.every(x => Array.isArray(x.labels) && x.labels.every(_label => typeof _label === \"string\") && Array.isArray(x.scores) && x.scores.every(_score => typeof _score === \"number\") && typeof x.sequence === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{labels: string[], scores: number[], sequence: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/multimodal/documentQuestionAnswering.ts\nasync function documentQuestionAnswering(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      question: args.inputs.question,\n      // convert Blob or ArrayBuffer to base64\n      image: base64FromBytes(new Uint8Array(args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()))\n    }\n  };\n  const res = toArray(await request(reqArgs, {\n    ...options,\n    taskHint: \"document-question-answering\"\n  }))?.[0];\n  const isValidOutput = typeof res?.answer === \"string\" && (typeof res.end === \"number\" || typeof res.end === \"undefined\") && (typeof res.score === \"number\" || typeof res.score === \"undefined\") && (typeof res.start === \"number\" || typeof res.start === \"undefined\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, end?: number, score?: number, start?: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/multimodal/visualQuestionAnswering.ts\nasync function visualQuestionAnswering(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      question: args.inputs.question,\n      // convert Blob or ArrayBuffer to base64\n      image: base64FromBytes(new Uint8Array(args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()))\n    }\n  };\n  const res = (await request(reqArgs, {\n    ...options,\n    taskHint: \"visual-question-answering\"\n  }))?.[0];\n  const isValidOutput = typeof res?.answer === \"string\" && typeof res.score === \"number\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/tabular/tabularRegression.ts\nasync function tabularRegression(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"tabular-regression\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/tasks/tabular/tabularClassification.ts\nasync function tabularClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"tabular-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/HfInference.ts\nvar HfInference = class {\n  accessToken;\n  defaultOptions;\n  constructor(accessToken = \"\", defaultOptions = {}) {\n    this.accessToken = accessToken;\n    this.defaultOptions = defaultOptions;\n    for (const [name, fn] of Object.entries(tasks_exports)) {\n      Object.defineProperty(this, name, {\n        enumerable: false,\n        value: (params, options) =>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        fn({\n          ...params,\n          accessToken\n        }, {\n          ...defaultOptions,\n          ...options\n        })\n      });\n    }\n  }\n  /**\n   * Returns copy of HfInference tied to a specified endpoint.\n   */\n  endpoint(endpointUrl) {\n    return new HfInferenceEndpoint(endpointUrl, this.accessToken, this.defaultOptions);\n  }\n};\nvar HfInferenceEndpoint = class {\n  constructor(endpointUrl, accessToken = \"\", defaultOptions = {}) {\n    accessToken;\n    defaultOptions;\n    for (const [name, fn] of Object.entries(tasks_exports)) {\n      Object.defineProperty(this, name, {\n        enumerable: false,\n        value: (params, options) =>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        fn({\n          ...params,\n          accessToken,\n          model: endpointUrl\n        }, {\n          ...defaultOptions,\n          ...options\n        })\n      });\n    }\n  }\n};\nexport { HfInference, HfInferenceEndpoint, InferenceOutputError, audioClassification, audioToAudio, automaticSpeechRecognition, documentQuestionAnswering, featureExtraction, fillMask, imageClassification, imageSegmentation, imageToImage, imageToText, objectDetection, questionAnswering, request, sentenceSimilarity, streamingRequest, summarization, tableQuestionAnswering, tabularClassification, tabularRegression, textClassification, textGeneration, textGenerationStream, textToImage, textToSpeech, tokenClassification, translation, visualQuestionAnswering, zeroShotClassification, zeroShotImageClassification };","map":{"version":3,"names":["__defProp","Object","defineProperty","__export","target","all","name","get","enumerable","tasks_exports","audioClassification","audioToAudio","automaticSpeechRecognition","documentQuestionAnswering","featureExtraction","fillMask","imageClassification","imageSegmentation","imageToImage","imageToText","objectDetection","questionAnswering","request","sentenceSimilarity","streamingRequest","summarization","tableQuestionAnswering","tabularClassification","tabularRegression","textClassification","textGeneration","textGenerationStream","textToImage","textToSpeech","tokenClassification","translation","visualQuestionAnswering","zeroShotClassification","zeroShotImageClassification","isUrl","modelOrUrl","test","startsWith","taskCache","Map","CACHE_DURATION","MAX_CACHE_ITEMS","HF_HUB_URL","getDefaultTask","model","accessToken","options","key","cachedTask","date","Date","now","delete","modelTask","fetch","headers","Authorization","then","resp","json","pipeline_tag","catch","task","set","size","keys","next","value","HF_INFERENCE_API_BASE_URL","tasks","makeRequestOptions","args","_model","otherArgs","forceTask","includeCredentials","taskHint","wait_for_model","use_cache","dont_load_model","otherOptions","res","ok","taskInfo","models","id","Error","binary","data","url","credentials","info","method","body","JSON","stringify","signal","response","retry_on_error","status","output","error","blob","getLines","onLine","buffer","position","fieldLength","discardTrailingNewline","onChunk","arr","concat","bufLength","length","lineStart","lineEnd","subarray","getMessages","onId","onRetry","onMessage","message","newMessage","decoder","TextDecoder","line","field","decode","valueOffset","event","retry","parseInt","isNaN","a","b","Uint8Array","stream","reader","getReader","events","onEvent","push","done","read","parse","releaseLock","InferenceOutputError","TypeError","constructor","isValidOutput","Array","isArray","every","x","label","score","text","Blob","mask","generated_text","box","xmin","ymin","xmax","ymax","base64FromBytes","globalThis","Buffer","from","toString","bin","forEach","byte","String","fromCharCode","btoa","join","isBrowser","window","document","isWebWorker","self","reqArgs","parameters","inputs","ArrayBuffer","arrayBuffer","image","defaultTask","isNumArrayRec","maxDepth","curDepth","sequence","token","token_str","answer","end","start","summary_text","aggregator","cells","coordinates","coord","toArray","obj","entity_group","word","translation_text","labels","_label","scores","_score","question","HfInference","defaultOptions","fn","entries","params","endpoint","endpointUrl","HfInferenceEndpoint"],"sources":["E:/SaanjhSahaayak/temp/tempo/node_modules/@huggingface/inference/dist/index.js"],"sourcesContent":["/// <reference path=\"./index.d.ts\" />\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/tasks/index.ts\nvar tasks_exports = {};\n__export(tasks_exports, {\n  audioClassification: () => audioClassification,\n  audioToAudio: () => audioToAudio,\n  automaticSpeechRecognition: () => automaticSpeechRecognition,\n  documentQuestionAnswering: () => documentQuestionAnswering,\n  featureExtraction: () => featureExtraction,\n  fillMask: () => fillMask,\n  imageClassification: () => imageClassification,\n  imageSegmentation: () => imageSegmentation,\n  imageToImage: () => imageToImage,\n  imageToText: () => imageToText,\n  objectDetection: () => objectDetection,\n  questionAnswering: () => questionAnswering,\n  request: () => request,\n  sentenceSimilarity: () => sentenceSimilarity,\n  streamingRequest: () => streamingRequest,\n  summarization: () => summarization,\n  tableQuestionAnswering: () => tableQuestionAnswering,\n  tabularClassification: () => tabularClassification,\n  tabularRegression: () => tabularRegression,\n  textClassification: () => textClassification,\n  textGeneration: () => textGeneration,\n  textGenerationStream: () => textGenerationStream,\n  textToImage: () => textToImage,\n  textToSpeech: () => textToSpeech,\n  tokenClassification: () => tokenClassification,\n  translation: () => translation,\n  visualQuestionAnswering: () => visualQuestionAnswering,\n  zeroShotClassification: () => zeroShotClassification,\n  zeroShotImageClassification: () => zeroShotImageClassification\n});\n\n// src/lib/isUrl.ts\nfunction isUrl(modelOrUrl) {\n  return /^http(s?):/.test(modelOrUrl) || modelOrUrl.startsWith(\"/\");\n}\n\n// src/lib/getDefaultTask.ts\nvar taskCache = /* @__PURE__ */ new Map();\nvar CACHE_DURATION = 10 * 60 * 1e3;\nvar MAX_CACHE_ITEMS = 1e3;\nvar HF_HUB_URL = \"https://huggingface.co\";\nasync function getDefaultTask(model, accessToken, options) {\n  if (isUrl(model)) {\n    return null;\n  }\n  const key = `${model}:${accessToken}`;\n  let cachedTask = taskCache.get(key);\n  if (cachedTask && cachedTask.date < new Date(Date.now() - CACHE_DURATION)) {\n    taskCache.delete(key);\n    cachedTask = void 0;\n  }\n  if (cachedTask === void 0) {\n    const modelTask = await (options?.fetch ?? fetch)(`${HF_HUB_URL}/api/models/${model}?expand[]=pipeline_tag`, {\n      headers: accessToken ? { Authorization: `Bearer ${accessToken}` } : {}\n    }).then((resp) => resp.json()).then((json) => json.pipeline_tag).catch(() => null);\n    if (!modelTask) {\n      return null;\n    }\n    cachedTask = { task: modelTask, date: /* @__PURE__ */ new Date() };\n    taskCache.set(key, { task: modelTask, date: /* @__PURE__ */ new Date() });\n    if (taskCache.size > MAX_CACHE_ITEMS) {\n      taskCache.delete(taskCache.keys().next().value);\n    }\n  }\n  return cachedTask.task;\n}\n\n// src/lib/makeRequestOptions.ts\nvar HF_INFERENCE_API_BASE_URL = \"https://api-inference.huggingface.co\";\nvar tasks = null;\nasync function makeRequestOptions(args, options) {\n  const { accessToken, model: _model, ...otherArgs } = args;\n  let { model } = args;\n  const {\n    forceTask: task,\n    includeCredentials,\n    taskHint,\n    wait_for_model,\n    use_cache,\n    dont_load_model,\n    ...otherOptions\n  } = options ?? {};\n  const headers = {};\n  if (accessToken) {\n    headers[\"Authorization\"] = `Bearer ${accessToken}`;\n  }\n  if (!model && !tasks && taskHint) {\n    const res = await fetch(`${HF_HUB_URL}/api/tasks`);\n    if (res.ok) {\n      tasks = await res.json();\n    }\n  }\n  if (!model && tasks && taskHint) {\n    const taskInfo = tasks[taskHint];\n    if (taskInfo) {\n      model = taskInfo.models[0].id;\n    }\n  }\n  if (!model) {\n    throw new Error(\"No model provided, and no default model found for this task\");\n  }\n  const binary = \"data\" in args && !!args.data;\n  if (!binary) {\n    headers[\"Content-Type\"] = \"application/json\";\n  }\n  if (wait_for_model) {\n    headers[\"X-Wait-For-Model\"] = \"true\";\n  }\n  if (use_cache === false) {\n    headers[\"X-Use-Cache\"] = \"false\";\n  }\n  if (dont_load_model) {\n    headers[\"X-Load-Model\"] = \"0\";\n  }\n  const url = (() => {\n    if (isUrl(model)) {\n      return model;\n    }\n    if (task) {\n      return `${HF_INFERENCE_API_BASE_URL}/pipeline/${task}/${model}`;\n    }\n    return `${HF_INFERENCE_API_BASE_URL}/models/${model}`;\n  })();\n  let credentials;\n  if (typeof includeCredentials === \"string\") {\n    credentials = includeCredentials;\n  } else if (includeCredentials === true) {\n    credentials = \"include\";\n  }\n  const info = {\n    headers,\n    method: \"POST\",\n    body: binary ? args.data : JSON.stringify({\n      ...otherArgs,\n      options: options && otherOptions\n    }),\n    ...credentials && { credentials },\n    signal: options?.signal\n  };\n  return { url, info };\n}\n\n// src/tasks/custom/request.ts\nasync function request(args, options) {\n  const { url, info } = await makeRequestOptions(args, options);\n  const response = await (options?.fetch ?? fetch)(url, info);\n  if (options?.retry_on_error !== false && response.status === 503 && !options?.wait_for_model) {\n    return request(args, {\n      ...options,\n      wait_for_model: true\n    });\n  }\n  if (!response.ok) {\n    if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n      const output = await response.json();\n      if (output.error) {\n        throw new Error(output.error);\n      }\n    }\n    throw new Error(\"An error occurred while fetching the blob\");\n  }\n  if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n    return await response.json();\n  }\n  return await response.blob();\n}\n\n// src/vendor/fetch-event-source/parse.ts\nfunction getLines(onLine) {\n  let buffer;\n  let position;\n  let fieldLength;\n  let discardTrailingNewline = false;\n  return function onChunk(arr) {\n    if (buffer === void 0) {\n      buffer = arr;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      buffer = concat(buffer, arr);\n    }\n    const bufLength = buffer.length;\n    let lineStart = 0;\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10 /* NewLine */) {\n          lineStart = ++position;\n        }\n        discardTrailingNewline = false;\n      }\n      let lineEnd = -1;\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58 /* Colon */:\n            if (fieldLength === -1) {\n              fieldLength = position - lineStart;\n            }\n            break;\n          case 13 /* CarriageReturn */:\n            discardTrailingNewline = true;\n          case 10 /* NewLine */:\n            lineEnd = position;\n            break;\n        }\n      }\n      if (lineEnd === -1) {\n        break;\n      }\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n      lineStart = position;\n      fieldLength = -1;\n    }\n    if (lineStart === bufLength) {\n      buffer = void 0;\n    } else if (lineStart !== 0) {\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\nfunction getMessages(onId, onRetry, onMessage) {\n  let message = newMessage();\n  const decoder = new TextDecoder();\n  return function onLine(line, fieldLength) {\n    if (line.length === 0) {\n      onMessage?.(message);\n      message = newMessage();\n    } else if (fieldLength > 0) {\n      const field = decoder.decode(line.subarray(0, fieldLength));\n      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* Space */ ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n      switch (field) {\n        case \"data\":\n          message.data = message.data ? message.data + \"\\n\" + value : value;\n          break;\n        case \"event\":\n          message.event = value;\n          break;\n        case \"id\":\n          onId(message.id = value);\n          break;\n        case \"retry\":\n          const retry = parseInt(value, 10);\n          if (!isNaN(retry)) {\n            onRetry(message.retry = retry);\n          }\n          break;\n      }\n    }\n  };\n}\nfunction concat(a, b) {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\nfunction newMessage() {\n  return {\n    data: \"\",\n    event: \"\",\n    id: \"\",\n    retry: void 0\n  };\n}\n\n// src/tasks/custom/streamingRequest.ts\nasync function* streamingRequest(args, options) {\n  const { url, info } = await makeRequestOptions({ ...args, stream: true }, options);\n  const response = await (options?.fetch ?? fetch)(url, info);\n  if (options?.retry_on_error !== false && response.status === 503 && !options?.wait_for_model) {\n    return yield* streamingRequest(args, {\n      ...options,\n      wait_for_model: true\n    });\n  }\n  if (!response.ok) {\n    if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n      const output = await response.json();\n      if (output.error) {\n        throw new Error(output.error);\n      }\n    }\n    throw new Error(`Server response contains error: ${response.status}`);\n  }\n  if (!response.headers.get(\"content-type\")?.startsWith(\"text/event-stream\")) {\n    throw new Error(\n      `Server does not support event stream content type, it returned ` + response.headers.get(\"content-type\")\n    );\n  }\n  if (!response.body) {\n    return;\n  }\n  const reader = response.body.getReader();\n  let events = [];\n  const onEvent = (event) => {\n    events.push(event);\n  };\n  const onChunk = getLines(\n    getMessages(\n      () => {\n      },\n      () => {\n      },\n      onEvent\n    )\n  );\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done)\n        return;\n      onChunk(value);\n      for (const event of events) {\n        if (event.data.length > 0) {\n          const data = JSON.parse(event.data);\n          if (typeof data === \"object\" && data !== null && \"error\" in data) {\n            throw new Error(data.error);\n          }\n          yield data;\n        }\n      }\n      events = [];\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n// src/lib/InferenceOutputError.ts\nvar InferenceOutputError = class extends TypeError {\n  constructor(message) {\n    super(\n      `Invalid inference output: ${message}. Use the 'request' method with the same parameters to do a custom call with no type checking.`\n    );\n    this.name = \"InferenceOutputError\";\n  }\n};\n\n// src/tasks/audio/audioClassification.ts\nasync function audioClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"audio-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/audio/automaticSpeechRecognition.ts\nasync function automaticSpeechRecognition(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"automatic-speech-recognition\"\n  });\n  const isValidOutput = typeof res?.text === \"string\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {text: string}\");\n  }\n  return res;\n}\n\n// src/tasks/audio/textToSpeech.ts\nasync function textToSpeech(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-to-speech\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/tasks/audio/audioToAudio.ts\nasync function audioToAudio(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"audio-to-audio\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.label === \"string\" && typeof x.blob === \"string\" && typeof x[\"content-type\"] === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, blob: string, content-type: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageClassification.ts\nasync function imageClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"image-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageSegmentation.ts\nasync function imageSegmentation(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"image-segmentation\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.mask === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, mask: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageToText.ts\nasync function imageToText(args, options) {\n  const res = (await request(args, {\n    ...options,\n    taskHint: \"image-to-text\"\n  }))?.[0];\n  if (typeof res?.generated_text !== \"string\") {\n    throw new InferenceOutputError(\"Expected {generated_text: string}\");\n  }\n  return res;\n}\n\n// src/tasks/cv/objectDetection.ts\nasync function objectDetection(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"object-detection\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.label === \"string\" && typeof x.score === \"number\" && typeof x.box.xmin === \"number\" && typeof x.box.ymin === \"number\" && typeof x.box.xmax === \"number\" && typeof x.box.ymax === \"number\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected Array<{label:string; score:number; box:{xmin:number; ymin:number; xmax:number; ymax:number}}>\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/cv/textToImage.ts\nasync function textToImage(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-to-image\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// ../shared/src/base64FromBytes.ts\nfunction base64FromBytes(arr) {\n  if (globalThis.Buffer) {\n    return globalThis.Buffer.from(arr).toString(\"base64\");\n  } else {\n    const bin = [];\n    arr.forEach((byte) => {\n      bin.push(String.fromCharCode(byte));\n    });\n    return globalThis.btoa(bin.join(\"\"));\n  }\n}\n\n// ../shared/src/isBackend.ts\nvar isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\nvar isWebWorker = typeof self === \"object\" && self.constructor && self.constructor.name === \"DedicatedWorkerGlobalScope\";\n\n// src/tasks/cv/imageToImage.ts\nasync function imageToImage(args, options) {\n  let reqArgs;\n  if (!args.parameters) {\n    reqArgs = {\n      accessToken: args.accessToken,\n      model: args.model,\n      data: args.inputs\n    };\n  } else {\n    reqArgs = {\n      ...args,\n      inputs: base64FromBytes(\n        new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer())\n      )\n    };\n  }\n  const res = await request(reqArgs, {\n    ...options,\n    taskHint: \"image-to-image\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/tasks/cv/zeroShotImageClassification.ts\nasync function zeroShotImageClassification(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      image: base64FromBytes(\n        new Uint8Array(\n          args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()\n        )\n      )\n    }\n  };\n  const res = await request(reqArgs, {\n    ...options,\n    taskHint: \"zero-shot-image-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/featureExtraction.ts\nasync function featureExtraction(args, options) {\n  const defaultTask = args.model ? await getDefaultTask(args.model, args.accessToken, options) : void 0;\n  const res = await request(args, {\n    ...options,\n    taskHint: \"feature-extraction\",\n    ...defaultTask === \"sentence-similarity\" && { forceTask: \"feature-extraction\" }\n  });\n  let isValidOutput = true;\n  const isNumArrayRec = (arr, maxDepth, curDepth = 0) => {\n    if (curDepth > maxDepth)\n      return false;\n    if (arr.every((x) => Array.isArray(x))) {\n      return arr.every((x) => isNumArrayRec(x, maxDepth, curDepth + 1));\n    } else {\n      return arr.every((x) => typeof x === \"number\");\n    }\n  };\n  isValidOutput = Array.isArray(res) && isNumArrayRec(res, 3, 0);\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<number[][][] | number[][] | number[] | number>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/fillMask.ts\nasync function fillMask(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"fill-mask\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.score === \"number\" && typeof x.sequence === \"string\" && typeof x.token === \"number\" && typeof x.token_str === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected Array<{score: number, sequence: string, token: number, token_str: string}>\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/nlp/questionAnswering.ts\nasync function questionAnswering(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"question-answering\"\n  });\n  const isValidOutput = typeof res === \"object\" && !!res && typeof res.answer === \"string\" && typeof res.end === \"number\" && typeof res.score === \"number\" && typeof res.start === \"number\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {answer: string, end: number, score: number, start: number}\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/sentenceSimilarity.ts\nasync function sentenceSimilarity(args, options) {\n  const defaultTask = args.model ? await getDefaultTask(args.model, args.accessToken, options) : void 0;\n  const res = await request(args, {\n    ...options,\n    taskHint: \"sentence-similarity\",\n    ...defaultTask === \"feature-extraction\" && { forceTask: \"sentence-similarity\" }\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/summarization.ts\nasync function summarization(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"summarization\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.summary_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{summary_text: string}>\");\n  }\n  return res?.[0];\n}\n\n// src/tasks/nlp/tableQuestionAnswering.ts\nasync function tableQuestionAnswering(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"table-question-answering\"\n  });\n  const isValidOutput = typeof res?.aggregator === \"string\" && typeof res.answer === \"string\" && Array.isArray(res.cells) && res.cells.every((x) => typeof x === \"string\") && Array.isArray(res.coordinates) && res.coordinates.every((coord) => Array.isArray(coord) && coord.every((x) => typeof x === \"number\"));\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected {aggregator: string, answer: string, cells: string[], coordinates: number[][]}\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/nlp/textClassification.ts\nasync function textClassification(args, options) {\n  const res = (await request(args, {\n    ...options,\n    taskHint: \"text-classification\"\n  }))?.[0];\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/textGeneration.ts\nasync function textGeneration(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-generation\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.generated_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{generated_text: string}>\");\n  }\n  return res?.[0];\n}\n\n// src/tasks/nlp/textGenerationStream.ts\nasync function* textGenerationStream(args, options) {\n  yield* streamingRequest(args, {\n    ...options,\n    taskHint: \"text-generation\"\n  });\n}\n\n// src/utils/toArray.ts\nfunction toArray(obj) {\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return [obj];\n}\n\n// src/tasks/nlp/tokenClassification.ts\nasync function tokenClassification(args, options) {\n  const res = toArray(\n    await request(args, {\n      ...options,\n      taskHint: \"token-classification\"\n    })\n  );\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.end === \"number\" && typeof x.entity_group === \"string\" && typeof x.score === \"number\" && typeof x.start === \"number\" && typeof x.word === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected Array<{end: number, entity_group: string, score: number, start: number, word: string}>\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/nlp/translation.ts\nasync function translation(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"translation\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.translation_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected type Array<{translation_text: string}>\");\n  }\n  return res?.length === 1 ? res?.[0] : res;\n}\n\n// src/tasks/nlp/zeroShotClassification.ts\nasync function zeroShotClassification(args, options) {\n  const res = toArray(\n    await request(args, {\n      ...options,\n      taskHint: \"zero-shot-classification\"\n    })\n  );\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => Array.isArray(x.labels) && x.labels.every((_label) => typeof _label === \"string\") && Array.isArray(x.scores) && x.scores.every((_score) => typeof _score === \"number\") && typeof x.sequence === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{labels: string[], scores: number[], sequence: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/multimodal/documentQuestionAnswering.ts\nasync function documentQuestionAnswering(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      question: args.inputs.question,\n      // convert Blob or ArrayBuffer to base64\n      image: base64FromBytes(\n        new Uint8Array(\n          args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()\n        )\n      )\n    }\n  };\n  const res = toArray(\n    await request(reqArgs, {\n      ...options,\n      taskHint: \"document-question-answering\"\n    })\n  )?.[0];\n  const isValidOutput = typeof res?.answer === \"string\" && (typeof res.end === \"number\" || typeof res.end === \"undefined\") && (typeof res.score === \"number\" || typeof res.score === \"undefined\") && (typeof res.start === \"number\" || typeof res.start === \"undefined\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, end?: number, score?: number, start?: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/multimodal/visualQuestionAnswering.ts\nasync function visualQuestionAnswering(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      question: args.inputs.question,\n      // convert Blob or ArrayBuffer to base64\n      image: base64FromBytes(\n        new Uint8Array(\n          args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()\n        )\n      )\n    }\n  };\n  const res = (await request(reqArgs, {\n    ...options,\n    taskHint: \"visual-question-answering\"\n  }))?.[0];\n  const isValidOutput = typeof res?.answer === \"string\" && typeof res.score === \"number\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/tabular/tabularRegression.ts\nasync function tabularRegression(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"tabular-regression\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/tasks/tabular/tabularClassification.ts\nasync function tabularClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"tabular-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/HfInference.ts\nvar HfInference = class {\n  accessToken;\n  defaultOptions;\n  constructor(accessToken = \"\", defaultOptions = {}) {\n    this.accessToken = accessToken;\n    this.defaultOptions = defaultOptions;\n    for (const [name, fn] of Object.entries(tasks_exports)) {\n      Object.defineProperty(this, name, {\n        enumerable: false,\n        value: (params, options) => (\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          fn({ ...params, accessToken }, { ...defaultOptions, ...options })\n        )\n      });\n    }\n  }\n  /**\n   * Returns copy of HfInference tied to a specified endpoint.\n   */\n  endpoint(endpointUrl) {\n    return new HfInferenceEndpoint(endpointUrl, this.accessToken, this.defaultOptions);\n  }\n};\nvar HfInferenceEndpoint = class {\n  constructor(endpointUrl, accessToken = \"\", defaultOptions = {}) {\n    accessToken;\n    defaultOptions;\n    for (const [name, fn] of Object.entries(tasks_exports)) {\n      Object.defineProperty(this, name, {\n        enumerable: false,\n        value: (params, options) => (\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          fn({ ...params, accessToken, model: endpointUrl }, { ...defaultOptions, ...options })\n        )\n      });\n    }\n  }\n};\nexport {\n  HfInference,\n  HfInferenceEndpoint,\n  InferenceOutputError,\n  audioClassification,\n  audioToAudio,\n  automaticSpeechRecognition,\n  documentQuestionAnswering,\n  featureExtraction,\n  fillMask,\n  imageClassification,\n  imageSegmentation,\n  imageToImage,\n  imageToText,\n  objectDetection,\n  questionAnswering,\n  request,\n  sentenceSimilarity,\n  streamingRequest,\n  summarization,\n  tableQuestionAnswering,\n  tabularClassification,\n  tabularRegression,\n  textClassification,\n  textGeneration,\n  textGenerationStream,\n  textToImage,\n  textToSpeech,\n  tokenClassification,\n  translation,\n  visualQuestionAnswering,\n  zeroShotClassification,\n  zeroShotImageClassification\n};\n"],"mappings":"AAAA;AACA,IAAIA,SAAS,GAAGC,MAAM,CAACC,cAAc;AACrC,IAAIC,QAAQ,GAAGA,CAACC,MAAM,EAAEC,GAAG,KAAK;EAC9B,KAAK,IAAIC,IAAI,IAAID,GAAG,EAClBL,SAAS,CAACI,MAAM,EAAEE,IAAI,EAAE;IAAEC,GAAG,EAAEF,GAAG,CAACC,IAAI,CAAC;IAAEE,UAAU,EAAE;EAAK,CAAC,CAAC;AACjE,CAAC;;AAED;AACA,IAAIC,aAAa,GAAG,CAAC,CAAC;AACtBN,QAAQ,CAACM,aAAa,EAAE;EACtBC,mBAAmB,EAAEA,CAAA,KAAMA,mBAAmB;EAC9CC,YAAY,EAAEA,CAAA,KAAMA,YAAY;EAChCC,0BAA0B,EAAEA,CAAA,KAAMA,0BAA0B;EAC5DC,yBAAyB,EAAEA,CAAA,KAAMA,yBAAyB;EAC1DC,iBAAiB,EAAEA,CAAA,KAAMA,iBAAiB;EAC1CC,QAAQ,EAAEA,CAAA,KAAMA,QAAQ;EACxBC,mBAAmB,EAAEA,CAAA,KAAMA,mBAAmB;EAC9CC,iBAAiB,EAAEA,CAAA,KAAMA,iBAAiB;EAC1CC,YAAY,EAAEA,CAAA,KAAMA,YAAY;EAChCC,WAAW,EAAEA,CAAA,KAAMA,WAAW;EAC9BC,eAAe,EAAEA,CAAA,KAAMA,eAAe;EACtCC,iBAAiB,EAAEA,CAAA,KAAMA,iBAAiB;EAC1CC,OAAO,EAAEA,CAAA,KAAMA,OAAO;EACtBC,kBAAkB,EAAEA,CAAA,KAAMA,kBAAkB;EAC5CC,gBAAgB,EAAEA,CAAA,KAAMA,gBAAgB;EACxCC,aAAa,EAAEA,CAAA,KAAMA,aAAa;EAClCC,sBAAsB,EAAEA,CAAA,KAAMA,sBAAsB;EACpDC,qBAAqB,EAAEA,CAAA,KAAMA,qBAAqB;EAClDC,iBAAiB,EAAEA,CAAA,KAAMA,iBAAiB;EAC1CC,kBAAkB,EAAEA,CAAA,KAAMA,kBAAkB;EAC5CC,cAAc,EAAEA,CAAA,KAAMA,cAAc;EACpCC,oBAAoB,EAAEA,CAAA,KAAMA,oBAAoB;EAChDC,WAAW,EAAEA,CAAA,KAAMA,WAAW;EAC9BC,YAAY,EAAEA,CAAA,KAAMA,YAAY;EAChCC,mBAAmB,EAAEA,CAAA,KAAMA,mBAAmB;EAC9CC,WAAW,EAAEA,CAAA,KAAMA,WAAW;EAC9BC,uBAAuB,EAAEA,CAAA,KAAMA,uBAAuB;EACtDC,sBAAsB,EAAEA,CAAA,KAAMA,sBAAsB;EACpDC,2BAA2B,EAAEA,CAAA,KAAMA;AACrC,CAAC,CAAC;;AAEF;AACA,SAASC,KAAKA,CAACC,UAAU,EAAE;EACzB,OAAO,YAAY,CAACC,IAAI,CAACD,UAAU,CAAC,IAAIA,UAAU,CAACE,UAAU,CAAC,GAAG,CAAC;AACpE;;AAEA;AACA,IAAIC,SAAS,GAAG,eAAgB,IAAIC,GAAG,CAAC,CAAC;AACzC,IAAIC,cAAc,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG;AAClC,IAAIC,eAAe,GAAG,GAAG;AACzB,IAAIC,UAAU,GAAG,wBAAwB;AACzC,eAAeC,cAAcA,CAACC,KAAK,EAAEC,WAAW,EAAEC,OAAO,EAAE;EACzD,IAAIZ,KAAK,CAACU,KAAK,CAAC,EAAE;IAChB,OAAO,IAAI;EACb;EACA,MAAMG,GAAG,GAAI,GAAEH,KAAM,IAAGC,WAAY,EAAC;EACrC,IAAIG,UAAU,GAAGV,SAAS,CAACpC,GAAG,CAAC6C,GAAG,CAAC;EACnC,IAAIC,UAAU,IAAIA,UAAU,CAACC,IAAI,GAAG,IAAIC,IAAI,CAACA,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGX,cAAc,CAAC,EAAE;IACzEF,SAAS,CAACc,MAAM,CAACL,GAAG,CAAC;IACrBC,UAAU,GAAG,KAAK,CAAC;EACrB;EACA,IAAIA,UAAU,KAAK,KAAK,CAAC,EAAE;IACzB,MAAMK,SAAS,GAAG,MAAM,CAACP,OAAO,EAAEQ,KAAK,IAAIA,KAAK,EAAG,GAAEZ,UAAW,eAAcE,KAAM,wBAAuB,EAAE;MAC3GW,OAAO,EAAEV,WAAW,GAAG;QAAEW,aAAa,EAAG,UAASX,WAAY;MAAE,CAAC,GAAG,CAAC;IACvE,CAAC,CAAC,CAACY,IAAI,CAAEC,IAAI,IAAKA,IAAI,CAACC,IAAI,CAAC,CAAC,CAAC,CAACF,IAAI,CAAEE,IAAI,IAAKA,IAAI,CAACC,YAAY,CAAC,CAACC,KAAK,CAAC,MAAM,IAAI,CAAC;IAClF,IAAI,CAACR,SAAS,EAAE;MACd,OAAO,IAAI;IACb;IACAL,UAAU,GAAG;MAAEc,IAAI,EAAET,SAAS;MAAEJ,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC;IAAE,CAAC;IAClEZ,SAAS,CAACyB,GAAG,CAAChB,GAAG,EAAE;MAAEe,IAAI,EAAET,SAAS;MAAEJ,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC;IAAE,CAAC,CAAC;IACzE,IAAIZ,SAAS,CAAC0B,IAAI,GAAGvB,eAAe,EAAE;MACpCH,SAAS,CAACc,MAAM,CAACd,SAAS,CAAC2B,IAAI,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,CAACC,KAAK,CAAC;IACjD;EACF;EACA,OAAOnB,UAAU,CAACc,IAAI;AACxB;;AAEA;AACA,IAAIM,yBAAyB,GAAG,sCAAsC;AACtE,IAAIC,KAAK,GAAG,IAAI;AAChB,eAAeC,kBAAkBA,CAACC,IAAI,EAAEzB,OAAO,EAAE;EAC/C,MAAM;IAAED,WAAW;IAAED,KAAK,EAAE4B,MAAM;IAAE,GAAGC;EAAU,CAAC,GAAGF,IAAI;EACzD,IAAI;IAAE3B;EAAM,CAAC,GAAG2B,IAAI;EACpB,MAAM;IACJG,SAAS,EAAEZ,IAAI;IACfa,kBAAkB;IAClBC,QAAQ;IACRC,cAAc;IACdC,SAAS;IACTC,eAAe;IACf,GAAGC;EACL,CAAC,GAAGlC,OAAO,IAAI,CAAC,CAAC;EACjB,MAAMS,OAAO,GAAG,CAAC,CAAC;EAClB,IAAIV,WAAW,EAAE;IACfU,OAAO,CAAC,eAAe,CAAC,GAAI,UAASV,WAAY,EAAC;EACpD;EACA,IAAI,CAACD,KAAK,IAAI,CAACyB,KAAK,IAAIO,QAAQ,EAAE;IAChC,MAAMK,GAAG,GAAG,MAAM3B,KAAK,CAAE,GAAEZ,UAAW,YAAW,CAAC;IAClD,IAAIuC,GAAG,CAACC,EAAE,EAAE;MACVb,KAAK,GAAG,MAAMY,GAAG,CAACtB,IAAI,CAAC,CAAC;IAC1B;EACF;EACA,IAAI,CAACf,KAAK,IAAIyB,KAAK,IAAIO,QAAQ,EAAE;IAC/B,MAAMO,QAAQ,GAAGd,KAAK,CAACO,QAAQ,CAAC;IAChC,IAAIO,QAAQ,EAAE;MACZvC,KAAK,GAAGuC,QAAQ,CAACC,MAAM,CAAC,CAAC,CAAC,CAACC,EAAE;IAC/B;EACF;EACA,IAAI,CAACzC,KAAK,EAAE;IACV,MAAM,IAAI0C,KAAK,CAAC,6DAA6D,CAAC;EAChF;EACA,MAAMC,MAAM,GAAG,MAAM,IAAIhB,IAAI,IAAI,CAAC,CAACA,IAAI,CAACiB,IAAI;EAC5C,IAAI,CAACD,MAAM,EAAE;IACXhC,OAAO,CAAC,cAAc,CAAC,GAAG,kBAAkB;EAC9C;EACA,IAAIsB,cAAc,EAAE;IAClBtB,OAAO,CAAC,kBAAkB,CAAC,GAAG,MAAM;EACtC;EACA,IAAIuB,SAAS,KAAK,KAAK,EAAE;IACvBvB,OAAO,CAAC,aAAa,CAAC,GAAG,OAAO;EAClC;EACA,IAAIwB,eAAe,EAAE;IACnBxB,OAAO,CAAC,cAAc,CAAC,GAAG,GAAG;EAC/B;EACA,MAAMkC,GAAG,GAAG,CAAC,MAAM;IACjB,IAAIvD,KAAK,CAACU,KAAK,CAAC,EAAE;MAChB,OAAOA,KAAK;IACd;IACA,IAAIkB,IAAI,EAAE;MACR,OAAQ,GAAEM,yBAA0B,aAAYN,IAAK,IAAGlB,KAAM,EAAC;IACjE;IACA,OAAQ,GAAEwB,yBAA0B,WAAUxB,KAAM,EAAC;EACvD,CAAC,EAAE,CAAC;EACJ,IAAI8C,WAAW;EACf,IAAI,OAAOf,kBAAkB,KAAK,QAAQ,EAAE;IAC1Ce,WAAW,GAAGf,kBAAkB;EAClC,CAAC,MAAM,IAAIA,kBAAkB,KAAK,IAAI,EAAE;IACtCe,WAAW,GAAG,SAAS;EACzB;EACA,MAAMC,IAAI,GAAG;IACXpC,OAAO;IACPqC,MAAM,EAAE,MAAM;IACdC,IAAI,EAAEN,MAAM,GAAGhB,IAAI,CAACiB,IAAI,GAAGM,IAAI,CAACC,SAAS,CAAC;MACxC,GAAGtB,SAAS;MACZ3B,OAAO,EAAEA,OAAO,IAAIkC;IACtB,CAAC,CAAC;IACF,IAAGU,WAAW,IAAI;MAAEA;IAAY,CAAC;IACjCM,MAAM,EAAElD,OAAO,EAAEkD;EACnB,CAAC;EACD,OAAO;IAAEP,GAAG;IAAEE;EAAK,CAAC;AACtB;;AAEA;AACA,eAAe1E,OAAOA,CAACsD,IAAI,EAAEzB,OAAO,EAAE;EACpC,MAAM;IAAE2C,GAAG;IAAEE;EAAK,CAAC,GAAG,MAAMrB,kBAAkB,CAACC,IAAI,EAAEzB,OAAO,CAAC;EAC7D,MAAMmD,QAAQ,GAAG,MAAM,CAACnD,OAAO,EAAEQ,KAAK,IAAIA,KAAK,EAAEmC,GAAG,EAAEE,IAAI,CAAC;EAC3D,IAAI7C,OAAO,EAAEoD,cAAc,KAAK,KAAK,IAAID,QAAQ,CAACE,MAAM,KAAK,GAAG,IAAI,CAACrD,OAAO,EAAE+B,cAAc,EAAE;IAC5F,OAAO5D,OAAO,CAACsD,IAAI,EAAE;MACnB,GAAGzB,OAAO;MACV+B,cAAc,EAAE;IAClB,CAAC,CAAC;EACJ;EACA,IAAI,CAACoB,QAAQ,CAACf,EAAE,EAAE;IAChB,IAAIe,QAAQ,CAAC1C,OAAO,CAACrD,GAAG,CAAC,cAAc,CAAC,EAAEmC,UAAU,CAAC,kBAAkB,CAAC,EAAE;MACxE,MAAM+D,MAAM,GAAG,MAAMH,QAAQ,CAACtC,IAAI,CAAC,CAAC;MACpC,IAAIyC,MAAM,CAACC,KAAK,EAAE;QAChB,MAAM,IAAIf,KAAK,CAACc,MAAM,CAACC,KAAK,CAAC;MAC/B;IACF;IACA,MAAM,IAAIf,KAAK,CAAC,2CAA2C,CAAC;EAC9D;EACA,IAAIW,QAAQ,CAAC1C,OAAO,CAACrD,GAAG,CAAC,cAAc,CAAC,EAAEmC,UAAU,CAAC,kBAAkB,CAAC,EAAE;IACxE,OAAO,MAAM4D,QAAQ,CAACtC,IAAI,CAAC,CAAC;EAC9B;EACA,OAAO,MAAMsC,QAAQ,CAACK,IAAI,CAAC,CAAC;AAC9B;;AAEA;AACA,SAASC,QAAQA,CAACC,MAAM,EAAE;EACxB,IAAIC,MAAM;EACV,IAAIC,QAAQ;EACZ,IAAIC,WAAW;EACf,IAAIC,sBAAsB,GAAG,KAAK;EAClC,OAAO,SAASC,OAAOA,CAACC,GAAG,EAAE;IAC3B,IAAIL,MAAM,KAAK,KAAK,CAAC,EAAE;MACrBA,MAAM,GAAGK,GAAG;MACZJ,QAAQ,GAAG,CAAC;MACZC,WAAW,GAAG,CAAC,CAAC;IAClB,CAAC,MAAM;MACLF,MAAM,GAAGM,MAAM,CAACN,MAAM,EAAEK,GAAG,CAAC;IAC9B;IACA,MAAME,SAAS,GAAGP,MAAM,CAACQ,MAAM;IAC/B,IAAIC,SAAS,GAAG,CAAC;IACjB,OAAOR,QAAQ,GAAGM,SAAS,EAAE;MAC3B,IAAIJ,sBAAsB,EAAE;QAC1B,IAAIH,MAAM,CAACC,QAAQ,CAAC,KAAK,EAAE,CAAC,eAAe;UACzCQ,SAAS,GAAG,EAAER,QAAQ;QACxB;QACAE,sBAAsB,GAAG,KAAK;MAChC;MACA,IAAIO,OAAO,GAAG,CAAC,CAAC;MAChB,OAAOT,QAAQ,GAAGM,SAAS,IAAIG,OAAO,KAAK,CAAC,CAAC,EAAE,EAAET,QAAQ,EAAE;QACzD,QAAQD,MAAM,CAACC,QAAQ,CAAC;UACtB,KAAK,EAAE,CAAC;YACN,IAAIC,WAAW,KAAK,CAAC,CAAC,EAAE;cACtBA,WAAW,GAAGD,QAAQ,GAAGQ,SAAS;YACpC;YACA;UACF,KAAK,EAAE,CAAC;YACNN,sBAAsB,GAAG,IAAI;UAC/B,KAAK,EAAE,CAAC;YACNO,OAAO,GAAGT,QAAQ;YAClB;QACJ;MACF;MACA,IAAIS,OAAO,KAAK,CAAC,CAAC,EAAE;QAClB;MACF;MACAX,MAAM,CAACC,MAAM,CAACW,QAAQ,CAACF,SAAS,EAAEC,OAAO,CAAC,EAAER,WAAW,CAAC;MACxDO,SAAS,GAAGR,QAAQ;MACpBC,WAAW,GAAG,CAAC,CAAC;IAClB;IACA,IAAIO,SAAS,KAAKF,SAAS,EAAE;MAC3BP,MAAM,GAAG,KAAK,CAAC;IACjB,CAAC,MAAM,IAAIS,SAAS,KAAK,CAAC,EAAE;MAC1BT,MAAM,GAAGA,MAAM,CAACW,QAAQ,CAACF,SAAS,CAAC;MACnCR,QAAQ,IAAIQ,SAAS;IACvB;EACF,CAAC;AACH;AACA,SAASG,WAAWA,CAACC,IAAI,EAAEC,OAAO,EAAEC,SAAS,EAAE;EAC7C,IAAIC,OAAO,GAAGC,UAAU,CAAC,CAAC;EAC1B,MAAMC,OAAO,GAAG,IAAIC,WAAW,CAAC,CAAC;EACjC,OAAO,SAASpB,MAAMA,CAACqB,IAAI,EAAElB,WAAW,EAAE;IACxC,IAAIkB,IAAI,CAACZ,MAAM,KAAK,CAAC,EAAE;MACrBO,SAAS,GAAGC,OAAO,CAAC;MACpBA,OAAO,GAAGC,UAAU,CAAC,CAAC;IACxB,CAAC,MAAM,IAAIf,WAAW,GAAG,CAAC,EAAE;MAC1B,MAAMmB,KAAK,GAAGH,OAAO,CAACI,MAAM,CAACF,IAAI,CAACT,QAAQ,CAAC,CAAC,EAAET,WAAW,CAAC,CAAC;MAC3D,MAAMqB,WAAW,GAAGrB,WAAW,IAAIkB,IAAI,CAAClB,WAAW,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC;MACpF,MAAMxC,KAAK,GAAGwD,OAAO,CAACI,MAAM,CAACF,IAAI,CAACT,QAAQ,CAACY,WAAW,CAAC,CAAC;MACxD,QAAQF,KAAK;QACX,KAAK,MAAM;UACTL,OAAO,CAACjC,IAAI,GAAGiC,OAAO,CAACjC,IAAI,GAAGiC,OAAO,CAACjC,IAAI,GAAG,IAAI,GAAGrB,KAAK,GAAGA,KAAK;UACjE;QACF,KAAK,OAAO;UACVsD,OAAO,CAACQ,KAAK,GAAG9D,KAAK;UACrB;QACF,KAAK,IAAI;UACPmD,IAAI,CAACG,OAAO,CAACpC,EAAE,GAAGlB,KAAK,CAAC;UACxB;QACF,KAAK,OAAO;UACV,MAAM+D,KAAK,GAAGC,QAAQ,CAAChE,KAAK,EAAE,EAAE,CAAC;UACjC,IAAI,CAACiE,KAAK,CAACF,KAAK,CAAC,EAAE;YACjBX,OAAO,CAACE,OAAO,CAACS,KAAK,GAAGA,KAAK,CAAC;UAChC;UACA;MACJ;IACF;EACF,CAAC;AACH;AACA,SAASnB,MAAMA,CAACsB,CAAC,EAAEC,CAAC,EAAE;EACpB,MAAMrD,GAAG,GAAG,IAAIsD,UAAU,CAACF,CAAC,CAACpB,MAAM,GAAGqB,CAAC,CAACrB,MAAM,CAAC;EAC/ChC,GAAG,CAAClB,GAAG,CAACsE,CAAC,CAAC;EACVpD,GAAG,CAAClB,GAAG,CAACuE,CAAC,EAAED,CAAC,CAACpB,MAAM,CAAC;EACpB,OAAOhC,GAAG;AACZ;AACA,SAASyC,UAAUA,CAAA,EAAG;EACpB,OAAO;IACLlC,IAAI,EAAE,EAAE;IACRyC,KAAK,EAAE,EAAE;IACT5C,EAAE,EAAE,EAAE;IACN6C,KAAK,EAAE,KAAK;EACd,CAAC;AACH;;AAEA;AACA,gBAAgB/G,gBAAgBA,CAACoD,IAAI,EAAEzB,OAAO,EAAE;EAC9C,MAAM;IAAE2C,GAAG;IAAEE;EAAK,CAAC,GAAG,MAAMrB,kBAAkB,CAAC;IAAE,GAAGC,IAAI;IAAEiE,MAAM,EAAE;EAAK,CAAC,EAAE1F,OAAO,CAAC;EAClF,MAAMmD,QAAQ,GAAG,MAAM,CAACnD,OAAO,EAAEQ,KAAK,IAAIA,KAAK,EAAEmC,GAAG,EAAEE,IAAI,CAAC;EAC3D,IAAI7C,OAAO,EAAEoD,cAAc,KAAK,KAAK,IAAID,QAAQ,CAACE,MAAM,KAAK,GAAG,IAAI,CAACrD,OAAO,EAAE+B,cAAc,EAAE;IAC5F,OAAO,OAAO1D,gBAAgB,CAACoD,IAAI,EAAE;MACnC,GAAGzB,OAAO;MACV+B,cAAc,EAAE;IAClB,CAAC,CAAC;EACJ;EACA,IAAI,CAACoB,QAAQ,CAACf,EAAE,EAAE;IAChB,IAAIe,QAAQ,CAAC1C,OAAO,CAACrD,GAAG,CAAC,cAAc,CAAC,EAAEmC,UAAU,CAAC,kBAAkB,CAAC,EAAE;MACxE,MAAM+D,MAAM,GAAG,MAAMH,QAAQ,CAACtC,IAAI,CAAC,CAAC;MACpC,IAAIyC,MAAM,CAACC,KAAK,EAAE;QAChB,MAAM,IAAIf,KAAK,CAACc,MAAM,CAACC,KAAK,CAAC;MAC/B;IACF;IACA,MAAM,IAAIf,KAAK,CAAE,mCAAkCW,QAAQ,CAACE,MAAO,EAAC,CAAC;EACvE;EACA,IAAI,CAACF,QAAQ,CAAC1C,OAAO,CAACrD,GAAG,CAAC,cAAc,CAAC,EAAEmC,UAAU,CAAC,mBAAmB,CAAC,EAAE;IAC1E,MAAM,IAAIiD,KAAK,CACZ,iEAAgE,GAAGW,QAAQ,CAAC1C,OAAO,CAACrD,GAAG,CAAC,cAAc,CACzG,CAAC;EACH;EACA,IAAI,CAAC+F,QAAQ,CAACJ,IAAI,EAAE;IAClB;EACF;EACA,MAAM4C,MAAM,GAAGxC,QAAQ,CAACJ,IAAI,CAAC6C,SAAS,CAAC,CAAC;EACxC,IAAIC,MAAM,GAAG,EAAE;EACf,MAAMC,OAAO,GAAIX,KAAK,IAAK;IACzBU,MAAM,CAACE,IAAI,CAACZ,KAAK,CAAC;EACpB,CAAC;EACD,MAAMpB,OAAO,GAAGN,QAAQ,CACtBc,WAAW,CACT,MAAM,CACN,CAAC,EACD,MAAM,CACN,CAAC,EACDuB,OACF,CACF,CAAC;EACD,IAAI;IACF,OAAO,IAAI,EAAE;MACX,MAAM;QAAEE,IAAI;QAAE3E;MAAM,CAAC,GAAG,MAAMsE,MAAM,CAACM,IAAI,CAAC,CAAC;MAC3C,IAAID,IAAI,EACN;MACFjC,OAAO,CAAC1C,KAAK,CAAC;MACd,KAAK,MAAM8D,KAAK,IAAIU,MAAM,EAAE;QAC1B,IAAIV,KAAK,CAACzC,IAAI,CAACyB,MAAM,GAAG,CAAC,EAAE;UACzB,MAAMzB,IAAI,GAAGM,IAAI,CAACkD,KAAK,CAACf,KAAK,CAACzC,IAAI,CAAC;UACnC,IAAI,OAAOA,IAAI,KAAK,QAAQ,IAAIA,IAAI,KAAK,IAAI,IAAI,OAAO,IAAIA,IAAI,EAAE;YAChE,MAAM,IAAIF,KAAK,CAACE,IAAI,CAACa,KAAK,CAAC;UAC7B;UACA,MAAMb,IAAI;QACZ;MACF;MACAmD,MAAM,GAAG,EAAE;IACb;EACF,CAAC,SAAS;IACRF,MAAM,CAACQ,WAAW,CAAC,CAAC;EACtB;AACF;;AAEA;AACA,IAAIC,oBAAoB,GAAG,cAAcC,SAAS,CAAC;EACjDC,WAAWA,CAAC3B,OAAO,EAAE;IACnB,KAAK,CACF,6BAA4BA,OAAQ,gGACvC,CAAC;IACD,IAAI,CAACxH,IAAI,GAAG,sBAAsB;EACpC;AACF,CAAC;;AAED;AACA,eAAeI,mBAAmBA,CAACkE,IAAI,EAAEzB,OAAO,EAAE;EAChD,MAAMmC,GAAG,GAAG,MAAMhE,OAAO,CAACsD,IAAI,EAAE;IAC9B,GAAGzB,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CAAC;EACF,MAAMyE,aAAa,GAAGC,KAAK,CAACC,OAAO,CAACtE,GAAG,CAAC,IAAIA,GAAG,CAACuE,KAAK,CAAEC,CAAC,IAAK,OAAOA,CAAC,CAACC,KAAK,KAAK,QAAQ,IAAI,OAAOD,CAAC,CAACE,KAAK,KAAK,QAAQ,CAAC;EACxH,IAAI,CAACN,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAAC,gDAAgD,CAAC;EAClF;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,eAAe1E,0BAA0BA,CAACgE,IAAI,EAAEzB,OAAO,EAAE;EACvD,MAAMmC,GAAG,GAAG,MAAMhE,OAAO,CAACsD,IAAI,EAAE;IAC9B,GAAGzB,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CAAC;EACF,MAAMyE,aAAa,GAAG,OAAOpE,GAAG,EAAE2E,IAAI,KAAK,QAAQ;EACnD,IAAI,CAACP,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAAC,yBAAyB,CAAC;EAC3D;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,eAAerD,YAAYA,CAAC2C,IAAI,EAAEzB,OAAO,EAAE;EACzC,MAAMmC,GAAG,GAAG,MAAMhE,OAAO,CAACsD,IAAI,EAAE;IAC9B,GAAGzB,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CAAC;EACF,MAAMyE,aAAa,GAAGpE,GAAG,IAAIA,GAAG,YAAY4E,IAAI;EAChD,IAAI,CAACR,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAAC,eAAe,CAAC;EACjD;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,eAAe3E,YAAYA,CAACiE,IAAI,EAAEzB,OAAO,EAAE;EACzC,MAAMmC,GAAG,GAAG,MAAMhE,OAAO,CAACsD,IAAI,EAAE;IAC9B,GAAGzB,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CAAC;EACF,MAAMyE,aAAa,GAAGC,KAAK,CAACC,OAAO,CAACtE,GAAG,CAAC,IAAIA,GAAG,CAACuE,KAAK,CAClDC,CAAC,IAAK,OAAOA,CAAC,CAACC,KAAK,KAAK,QAAQ,IAAI,OAAOD,CAAC,CAACnD,IAAI,KAAK,QAAQ,IAAI,OAAOmD,CAAC,CAAC,cAAc,CAAC,KAAK,QACnG,CAAC;EACD,IAAI,CAACJ,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAAC,qEAAqE,CAAC;EACvG;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,eAAetE,mBAAmBA,CAAC4D,IAAI,EAAEzB,OAAO,EAAE;EAChD,MAAMmC,GAAG,GAAG,MAAMhE,OAAO,CAACsD,IAAI,EAAE;IAC9B,GAAGzB,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CAAC;EACF,MAAMyE,aAAa,GAAGC,KAAK,CAACC,OAAO,CAACtE,GAAG,CAAC,IAAIA,GAAG,CAACuE,KAAK,CAAEC,CAAC,IAAK,OAAOA,CAAC,CAACC,KAAK,KAAK,QAAQ,IAAI,OAAOD,CAAC,CAACE,KAAK,KAAK,QAAQ,CAAC;EACxH,IAAI,CAACN,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAAC,gDAAgD,CAAC;EAClF;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,eAAerE,iBAAiBA,CAAC2D,IAAI,EAAEzB,OAAO,EAAE;EAC9C,MAAMmC,GAAG,GAAG,MAAMhE,OAAO,CAACsD,IAAI,EAAE;IAC9B,GAAGzB,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CAAC;EACF,MAAMyE,aAAa,GAAGC,KAAK,CAACC,OAAO,CAACtE,GAAG,CAAC,IAAIA,GAAG,CAACuE,KAAK,CAAEC,CAAC,IAAK,OAAOA,CAAC,CAACC,KAAK,KAAK,QAAQ,IAAI,OAAOD,CAAC,CAACK,IAAI,KAAK,QAAQ,IAAI,OAAOL,CAAC,CAACE,KAAK,KAAK,QAAQ,CAAC;EACtJ,IAAI,CAACN,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAAC,8DAA8D,CAAC;EAChG;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,eAAenE,WAAWA,CAACyD,IAAI,EAAEzB,OAAO,EAAE;EACxC,MAAMmC,GAAG,GAAG,CAAC,MAAMhE,OAAO,CAACsD,IAAI,EAAE;IAC/B,GAAGzB,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CAAC,IAAI,CAAC,CAAC;EACR,IAAI,OAAOK,GAAG,EAAE8E,cAAc,KAAK,QAAQ,EAAE;IAC3C,MAAM,IAAIb,oBAAoB,CAAC,mCAAmC,CAAC;EACrE;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,eAAelE,eAAeA,CAACwD,IAAI,EAAEzB,OAAO,EAAE;EAC5C,MAAMmC,GAAG,GAAG,MAAMhE,OAAO,CAACsD,IAAI,EAAE;IAC9B,GAAGzB,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CAAC;EACF,MAAMyE,aAAa,GAAGC,KAAK,CAACC,OAAO,CAACtE,GAAG,CAAC,IAAIA,GAAG,CAACuE,KAAK,CAClDC,CAAC,IAAK,OAAOA,CAAC,CAACC,KAAK,KAAK,QAAQ,IAAI,OAAOD,CAAC,CAACE,KAAK,KAAK,QAAQ,IAAI,OAAOF,CAAC,CAACO,GAAG,CAACC,IAAI,KAAK,QAAQ,IAAI,OAAOR,CAAC,CAACO,GAAG,CAACE,IAAI,KAAK,QAAQ,IAAI,OAAOT,CAAC,CAACO,GAAG,CAACG,IAAI,KAAK,QAAQ,IAAI,OAAOV,CAAC,CAACO,GAAG,CAACI,IAAI,KAAK,QACnM,CAAC;EACD,IAAI,CAACf,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAC5B,wGACF,CAAC;EACH;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,eAAetD,WAAWA,CAAC4C,IAAI,EAAEzB,OAAO,EAAE;EACxC,MAAMmC,GAAG,GAAG,MAAMhE,OAAO,CAACsD,IAAI,EAAE;IAC9B,GAAGzB,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CAAC;EACF,MAAMyE,aAAa,GAAGpE,GAAG,IAAIA,GAAG,YAAY4E,IAAI;EAChD,IAAI,CAACR,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAAC,eAAe,CAAC;EACjD;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,SAASoF,eAAeA,CAACvD,GAAG,EAAE;EAC5B,IAAIwD,UAAU,CAACC,MAAM,EAAE;IACrB,OAAOD,UAAU,CAACC,MAAM,CAACC,IAAI,CAAC1D,GAAG,CAAC,CAAC2D,QAAQ,CAAC,QAAQ,CAAC;EACvD,CAAC,MAAM;IACL,MAAMC,GAAG,GAAG,EAAE;IACd5D,GAAG,CAAC6D,OAAO,CAAEC,IAAI,IAAK;MACpBF,GAAG,CAAC7B,IAAI,CAACgC,MAAM,CAACC,YAAY,CAACF,IAAI,CAAC,CAAC;IACrC,CAAC,CAAC;IACF,OAAON,UAAU,CAACS,IAAI,CAACL,GAAG,CAACM,IAAI,CAAC,EAAE,CAAC,CAAC;EACtC;AACF;;AAEA;AACA,IAAIC,SAAS,GAAG,OAAOC,MAAM,KAAK,WAAW,IAAI,OAAOA,MAAM,CAACC,QAAQ,KAAK,WAAW;AACvF,IAAIC,WAAW,GAAG,OAAOC,IAAI,KAAK,QAAQ,IAAIA,IAAI,CAACjC,WAAW,IAAIiC,IAAI,CAACjC,WAAW,CAACnJ,IAAI,KAAK,4BAA4B;;AAExH;AACA,eAAeY,YAAYA,CAAC0D,IAAI,EAAEzB,OAAO,EAAE;EACzC,IAAIwI,OAAO;EACX,IAAI,CAAC/G,IAAI,CAACgH,UAAU,EAAE;IACpBD,OAAO,GAAG;MACRzI,WAAW,EAAE0B,IAAI,CAAC1B,WAAW;MAC7BD,KAAK,EAAE2B,IAAI,CAAC3B,KAAK;MACjB4C,IAAI,EAAEjB,IAAI,CAACiH;IACb,CAAC;EACH,CAAC,MAAM;IACLF,OAAO,GAAG;MACR,GAAG/G,IAAI;MACPiH,MAAM,EAAEnB,eAAe,CACrB,IAAI9B,UAAU,CAAChE,IAAI,CAACiH,MAAM,YAAYC,WAAW,GAAGlH,IAAI,CAACiH,MAAM,GAAG,MAAMjH,IAAI,CAACiH,MAAM,CAACE,WAAW,CAAC,CAAC,CACnG;IACF,CAAC;EACH;EACA,MAAMzG,GAAG,GAAG,MAAMhE,OAAO,CAACqK,OAAO,EAAE;IACjC,GAAGxI,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CAAC;EACF,MAAMyE,aAAa,GAAGpE,GAAG,IAAIA,GAAG,YAAY4E,IAAI;EAChD,IAAI,CAACR,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAAC,eAAe,CAAC;EACjD;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,eAAehD,2BAA2BA,CAACsC,IAAI,EAAEzB,OAAO,EAAE;EACxD,MAAMwI,OAAO,GAAG;IACd,GAAG/G,IAAI;IACPiH,MAAM,EAAE;MACNG,KAAK,EAAEtB,eAAe,CACpB,IAAI9B,UAAU,CACZhE,IAAI,CAACiH,MAAM,CAACG,KAAK,YAAYF,WAAW,GAAGlH,IAAI,CAACiH,MAAM,CAACG,KAAK,GAAG,MAAMpH,IAAI,CAACiH,MAAM,CAACG,KAAK,CAACD,WAAW,CAAC,CACrG,CACF;IACF;EACF,CAAC;EACD,MAAMzG,GAAG,GAAG,MAAMhE,OAAO,CAACqK,OAAO,EAAE;IACjC,GAAGxI,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CAAC;EACF,MAAMyE,aAAa,GAAGC,KAAK,CAACC,OAAO,CAACtE,GAAG,CAAC,IAAIA,GAAG,CAACuE,KAAK,CAAEC,CAAC,IAAK,OAAOA,CAAC,CAACC,KAAK,KAAK,QAAQ,IAAI,OAAOD,CAAC,CAACE,KAAK,KAAK,QAAQ,CAAC;EACxH,IAAI,CAACN,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAAC,gDAAgD,CAAC;EAClF;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,eAAexE,iBAAiBA,CAAC8D,IAAI,EAAEzB,OAAO,EAAE;EAC9C,MAAM8I,WAAW,GAAGrH,IAAI,CAAC3B,KAAK,GAAG,MAAMD,cAAc,CAAC4B,IAAI,CAAC3B,KAAK,EAAE2B,IAAI,CAAC1B,WAAW,EAAEC,OAAO,CAAC,GAAG,KAAK,CAAC;EACrG,MAAMmC,GAAG,GAAG,MAAMhE,OAAO,CAACsD,IAAI,EAAE;IAC9B,GAAGzB,OAAO;IACV8B,QAAQ,EAAE,oBAAoB;IAC9B,IAAGgH,WAAW,KAAK,qBAAqB,IAAI;MAAElH,SAAS,EAAE;IAAqB,CAAC;EACjF,CAAC,CAAC;EACF,IAAI2E,aAAa,GAAG,IAAI;EACxB,MAAMwC,aAAa,GAAGA,CAAC/E,GAAG,EAAEgF,QAAQ,EAAEC,QAAQ,GAAG,CAAC,KAAK;IACrD,IAAIA,QAAQ,GAAGD,QAAQ,EACrB,OAAO,KAAK;IACd,IAAIhF,GAAG,CAAC0C,KAAK,CAAEC,CAAC,IAAKH,KAAK,CAACC,OAAO,CAACE,CAAC,CAAC,CAAC,EAAE;MACtC,OAAO3C,GAAG,CAAC0C,KAAK,CAAEC,CAAC,IAAKoC,aAAa,CAACpC,CAAC,EAAEqC,QAAQ,EAAEC,QAAQ,GAAG,CAAC,CAAC,CAAC;IACnE,CAAC,MAAM;MACL,OAAOjF,GAAG,CAAC0C,KAAK,CAAEC,CAAC,IAAK,OAAOA,CAAC,KAAK,QAAQ,CAAC;IAChD;EACF,CAAC;EACDJ,aAAa,GAAGC,KAAK,CAACC,OAAO,CAACtE,GAAG,CAAC,IAAI4G,aAAa,CAAC5G,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC;EAC9D,IAAI,CAACoE,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAAC,+DAA+D,CAAC;EACjG;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,eAAevE,QAAQA,CAAC6D,IAAI,EAAEzB,OAAO,EAAE;EACrC,MAAMmC,GAAG,GAAG,MAAMhE,OAAO,CAACsD,IAAI,EAAE;IAC9B,GAAGzB,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CAAC;EACF,MAAMyE,aAAa,GAAGC,KAAK,CAACC,OAAO,CAACtE,GAAG,CAAC,IAAIA,GAAG,CAACuE,KAAK,CAClDC,CAAC,IAAK,OAAOA,CAAC,CAACE,KAAK,KAAK,QAAQ,IAAI,OAAOF,CAAC,CAACuC,QAAQ,KAAK,QAAQ,IAAI,OAAOvC,CAAC,CAACwC,KAAK,KAAK,QAAQ,IAAI,OAAOxC,CAAC,CAACyC,SAAS,KAAK,QAChI,CAAC;EACD,IAAI,CAAC7C,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAC5B,qFACF,CAAC;EACH;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,eAAejE,iBAAiBA,CAACuD,IAAI,EAAEzB,OAAO,EAAE;EAC9C,MAAMmC,GAAG,GAAG,MAAMhE,OAAO,CAACsD,IAAI,EAAE;IAC9B,GAAGzB,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CAAC;EACF,MAAMyE,aAAa,GAAG,OAAOpE,GAAG,KAAK,QAAQ,IAAI,CAAC,CAACA,GAAG,IAAI,OAAOA,GAAG,CAACkH,MAAM,KAAK,QAAQ,IAAI,OAAOlH,GAAG,CAACmH,GAAG,KAAK,QAAQ,IAAI,OAAOnH,GAAG,CAAC0E,KAAK,KAAK,QAAQ,IAAI,OAAO1E,GAAG,CAACoH,KAAK,KAAK,QAAQ;EACzL,IAAI,CAAChD,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAAC,sEAAsE,CAAC;EACxG;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,eAAe/D,kBAAkBA,CAACqD,IAAI,EAAEzB,OAAO,EAAE;EAC/C,MAAM8I,WAAW,GAAGrH,IAAI,CAAC3B,KAAK,GAAG,MAAMD,cAAc,CAAC4B,IAAI,CAAC3B,KAAK,EAAE2B,IAAI,CAAC1B,WAAW,EAAEC,OAAO,CAAC,GAAG,KAAK,CAAC;EACrG,MAAMmC,GAAG,GAAG,MAAMhE,OAAO,CAACsD,IAAI,EAAE;IAC9B,GAAGzB,OAAO;IACV8B,QAAQ,EAAE,qBAAqB;IAC/B,IAAGgH,WAAW,KAAK,oBAAoB,IAAI;MAAElH,SAAS,EAAE;IAAsB,CAAC;EACjF,CAAC,CAAC;EACF,MAAM2E,aAAa,GAAGC,KAAK,CAACC,OAAO,CAACtE,GAAG,CAAC,IAAIA,GAAG,CAACuE,KAAK,CAAEC,CAAC,IAAK,OAAOA,CAAC,KAAK,QAAQ,CAAC;EACnF,IAAI,CAACJ,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAAC,mBAAmB,CAAC;EACrD;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,eAAe7D,aAAaA,CAACmD,IAAI,EAAEzB,OAAO,EAAE;EAC1C,MAAMmC,GAAG,GAAG,MAAMhE,OAAO,CAACsD,IAAI,EAAE;IAC9B,GAAGzB,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CAAC;EACF,MAAMyE,aAAa,GAAGC,KAAK,CAACC,OAAO,CAACtE,GAAG,CAAC,IAAIA,GAAG,CAACuE,KAAK,CAAEC,CAAC,IAAK,OAAOA,CAAC,EAAE6C,YAAY,KAAK,QAAQ,CAAC;EACjG,IAAI,CAACjD,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAAC,wCAAwC,CAAC;EAC1E;EACA,OAAOjE,GAAG,GAAG,CAAC,CAAC;AACjB;;AAEA;AACA,eAAe5D,sBAAsBA,CAACkD,IAAI,EAAEzB,OAAO,EAAE;EACnD,MAAMmC,GAAG,GAAG,MAAMhE,OAAO,CAACsD,IAAI,EAAE;IAC9B,GAAGzB,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CAAC;EACF,MAAMyE,aAAa,GAAG,OAAOpE,GAAG,EAAEsH,UAAU,KAAK,QAAQ,IAAI,OAAOtH,GAAG,CAACkH,MAAM,KAAK,QAAQ,IAAI7C,KAAK,CAACC,OAAO,CAACtE,GAAG,CAACuH,KAAK,CAAC,IAAIvH,GAAG,CAACuH,KAAK,CAAChD,KAAK,CAAEC,CAAC,IAAK,OAAOA,CAAC,KAAK,QAAQ,CAAC,IAAIH,KAAK,CAACC,OAAO,CAACtE,GAAG,CAACwH,WAAW,CAAC,IAAIxH,GAAG,CAACwH,WAAW,CAACjD,KAAK,CAAEkD,KAAK,IAAKpD,KAAK,CAACC,OAAO,CAACmD,KAAK,CAAC,IAAIA,KAAK,CAAClD,KAAK,CAAEC,CAAC,IAAK,OAAOA,CAAC,KAAK,QAAQ,CAAC,CAAC;EACjT,IAAI,CAACJ,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAC5B,yFACF,CAAC;EACH;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,eAAezD,kBAAkBA,CAAC+C,IAAI,EAAEzB,OAAO,EAAE;EAC/C,MAAMmC,GAAG,GAAG,CAAC,MAAMhE,OAAO,CAACsD,IAAI,EAAE;IAC/B,GAAGzB,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CAAC,IAAI,CAAC,CAAC;EACR,MAAMyE,aAAa,GAAGC,KAAK,CAACC,OAAO,CAACtE,GAAG,CAAC,IAAIA,GAAG,CAACuE,KAAK,CAAEC,CAAC,IAAK,OAAOA,CAAC,EAAEC,KAAK,KAAK,QAAQ,IAAI,OAAOD,CAAC,CAACE,KAAK,KAAK,QAAQ,CAAC;EACzH,IAAI,CAACN,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAAC,gDAAgD,CAAC;EAClF;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,eAAexD,cAAcA,CAAC8C,IAAI,EAAEzB,OAAO,EAAE;EAC3C,MAAMmC,GAAG,GAAG,MAAMhE,OAAO,CAACsD,IAAI,EAAE;IAC9B,GAAGzB,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CAAC;EACF,MAAMyE,aAAa,GAAGC,KAAK,CAACC,OAAO,CAACtE,GAAG,CAAC,IAAIA,GAAG,CAACuE,KAAK,CAAEC,CAAC,IAAK,OAAOA,CAAC,EAAEM,cAAc,KAAK,QAAQ,CAAC;EACnG,IAAI,CAACV,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAAC,0CAA0C,CAAC;EAC5E;EACA,OAAOjE,GAAG,GAAG,CAAC,CAAC;AACjB;;AAEA;AACA,gBAAgBvD,oBAAoBA,CAAC6C,IAAI,EAAEzB,OAAO,EAAE;EAClD,OAAO3B,gBAAgB,CAACoD,IAAI,EAAE;IAC5B,GAAGzB,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CAAC;AACJ;;AAEA;AACA,SAAS+H,OAAOA,CAACC,GAAG,EAAE;EACpB,IAAItD,KAAK,CAACC,OAAO,CAACqD,GAAG,CAAC,EAAE;IACtB,OAAOA,GAAG;EACZ;EACA,OAAO,CAACA,GAAG,CAAC;AACd;;AAEA;AACA,eAAe/K,mBAAmBA,CAAC0C,IAAI,EAAEzB,OAAO,EAAE;EAChD,MAAMmC,GAAG,GAAG0H,OAAO,CACjB,MAAM1L,OAAO,CAACsD,IAAI,EAAE;IAClB,GAAGzB,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CACH,CAAC;EACD,MAAMyE,aAAa,GAAGC,KAAK,CAACC,OAAO,CAACtE,GAAG,CAAC,IAAIA,GAAG,CAACuE,KAAK,CAClDC,CAAC,IAAK,OAAOA,CAAC,CAAC2C,GAAG,KAAK,QAAQ,IAAI,OAAO3C,CAAC,CAACoD,YAAY,KAAK,QAAQ,IAAI,OAAOpD,CAAC,CAACE,KAAK,KAAK,QAAQ,IAAI,OAAOF,CAAC,CAAC4C,KAAK,KAAK,QAAQ,IAAI,OAAO5C,CAAC,CAACqD,IAAI,KAAK,QAC5J,CAAC;EACD,IAAI,CAACzD,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAC5B,iGACF,CAAC;EACH;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,eAAenD,WAAWA,CAACyC,IAAI,EAAEzB,OAAO,EAAE;EACxC,MAAMmC,GAAG,GAAG,MAAMhE,OAAO,CAACsD,IAAI,EAAE;IAC9B,GAAGzB,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CAAC;EACF,MAAMyE,aAAa,GAAGC,KAAK,CAACC,OAAO,CAACtE,GAAG,CAAC,IAAIA,GAAG,CAACuE,KAAK,CAAEC,CAAC,IAAK,OAAOA,CAAC,EAAEsD,gBAAgB,KAAK,QAAQ,CAAC;EACrG,IAAI,CAAC1D,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAAC,iDAAiD,CAAC;EACnF;EACA,OAAOjE,GAAG,EAAEgC,MAAM,KAAK,CAAC,GAAGhC,GAAG,GAAG,CAAC,CAAC,GAAGA,GAAG;AAC3C;;AAEA;AACA,eAAejD,sBAAsBA,CAACuC,IAAI,EAAEzB,OAAO,EAAE;EACnD,MAAMmC,GAAG,GAAG0H,OAAO,CACjB,MAAM1L,OAAO,CAACsD,IAAI,EAAE;IAClB,GAAGzB,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CACH,CAAC;EACD,MAAMyE,aAAa,GAAGC,KAAK,CAACC,OAAO,CAACtE,GAAG,CAAC,IAAIA,GAAG,CAACuE,KAAK,CAClDC,CAAC,IAAKH,KAAK,CAACC,OAAO,CAACE,CAAC,CAACuD,MAAM,CAAC,IAAIvD,CAAC,CAACuD,MAAM,CAACxD,KAAK,CAAEyD,MAAM,IAAK,OAAOA,MAAM,KAAK,QAAQ,CAAC,IAAI3D,KAAK,CAACC,OAAO,CAACE,CAAC,CAACyD,MAAM,CAAC,IAAIzD,CAAC,CAACyD,MAAM,CAAC1D,KAAK,CAAE2D,MAAM,IAAK,OAAOA,MAAM,KAAK,QAAQ,CAAC,IAAI,OAAO1D,CAAC,CAACuC,QAAQ,KAAK,QACzM,CAAC;EACD,IAAI,CAAC3C,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAAC,wEAAwE,CAAC;EAC1G;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,eAAezE,yBAAyBA,CAAC+D,IAAI,EAAEzB,OAAO,EAAE;EACtD,MAAMwI,OAAO,GAAG;IACd,GAAG/G,IAAI;IACPiH,MAAM,EAAE;MACN4B,QAAQ,EAAE7I,IAAI,CAACiH,MAAM,CAAC4B,QAAQ;MAC9B;MACAzB,KAAK,EAAEtB,eAAe,CACpB,IAAI9B,UAAU,CACZhE,IAAI,CAACiH,MAAM,CAACG,KAAK,YAAYF,WAAW,GAAGlH,IAAI,CAACiH,MAAM,CAACG,KAAK,GAAG,MAAMpH,IAAI,CAACiH,MAAM,CAACG,KAAK,CAACD,WAAW,CAAC,CACrG,CACF;IACF;EACF,CAAC;EACD,MAAMzG,GAAG,GAAG0H,OAAO,CACjB,MAAM1L,OAAO,CAACqK,OAAO,EAAE;IACrB,GAAGxI,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CACH,CAAC,GAAG,CAAC,CAAC;EACN,MAAMyE,aAAa,GAAG,OAAOpE,GAAG,EAAEkH,MAAM,KAAK,QAAQ,KAAK,OAAOlH,GAAG,CAACmH,GAAG,KAAK,QAAQ,IAAI,OAAOnH,GAAG,CAACmH,GAAG,KAAK,WAAW,CAAC,KAAK,OAAOnH,GAAG,CAAC0E,KAAK,KAAK,QAAQ,IAAI,OAAO1E,GAAG,CAAC0E,KAAK,KAAK,WAAW,CAAC,KAAK,OAAO1E,GAAG,CAACoH,KAAK,KAAK,QAAQ,IAAI,OAAOpH,GAAG,CAACoH,KAAK,KAAK,WAAW,CAAC;EACtQ,IAAI,CAAChD,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAAC,gFAAgF,CAAC;EAClH;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,eAAelD,uBAAuBA,CAACwC,IAAI,EAAEzB,OAAO,EAAE;EACpD,MAAMwI,OAAO,GAAG;IACd,GAAG/G,IAAI;IACPiH,MAAM,EAAE;MACN4B,QAAQ,EAAE7I,IAAI,CAACiH,MAAM,CAAC4B,QAAQ;MAC9B;MACAzB,KAAK,EAAEtB,eAAe,CACpB,IAAI9B,UAAU,CACZhE,IAAI,CAACiH,MAAM,CAACG,KAAK,YAAYF,WAAW,GAAGlH,IAAI,CAACiH,MAAM,CAACG,KAAK,GAAG,MAAMpH,IAAI,CAACiH,MAAM,CAACG,KAAK,CAACD,WAAW,CAAC,CACrG,CACF;IACF;EACF,CAAC;EACD,MAAMzG,GAAG,GAAG,CAAC,MAAMhE,OAAO,CAACqK,OAAO,EAAE;IAClC,GAAGxI,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CAAC,IAAI,CAAC,CAAC;EACR,MAAMyE,aAAa,GAAG,OAAOpE,GAAG,EAAEkH,MAAM,KAAK,QAAQ,IAAI,OAAOlH,GAAG,CAAC0E,KAAK,KAAK,QAAQ;EACtF,IAAI,CAACN,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAAC,iDAAiD,CAAC;EACnF;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,eAAe1D,iBAAiBA,CAACgD,IAAI,EAAEzB,OAAO,EAAE;EAC9C,MAAMmC,GAAG,GAAG,MAAMhE,OAAO,CAACsD,IAAI,EAAE;IAC9B,GAAGzB,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CAAC;EACF,MAAMyE,aAAa,GAAGC,KAAK,CAACC,OAAO,CAACtE,GAAG,CAAC,IAAIA,GAAG,CAACuE,KAAK,CAAEC,CAAC,IAAK,OAAOA,CAAC,KAAK,QAAQ,CAAC;EACnF,IAAI,CAACJ,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAAC,mBAAmB,CAAC;EACrD;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,eAAe3D,qBAAqBA,CAACiD,IAAI,EAAEzB,OAAO,EAAE;EAClD,MAAMmC,GAAG,GAAG,MAAMhE,OAAO,CAACsD,IAAI,EAAE;IAC9B,GAAGzB,OAAO;IACV8B,QAAQ,EAAE;EACZ,CAAC,CAAC;EACF,MAAMyE,aAAa,GAAGC,KAAK,CAACC,OAAO,CAACtE,GAAG,CAAC,IAAIA,GAAG,CAACuE,KAAK,CAAEC,CAAC,IAAK,OAAOA,CAAC,KAAK,QAAQ,CAAC;EACnF,IAAI,CAACJ,aAAa,EAAE;IAClB,MAAM,IAAIH,oBAAoB,CAAC,mBAAmB,CAAC;EACrD;EACA,OAAOjE,GAAG;AACZ;;AAEA;AACA,IAAIoI,WAAW,GAAG,MAAM;EACtBxK,WAAW;EACXyK,cAAc;EACdlE,WAAWA,CAACvG,WAAW,GAAG,EAAE,EAAEyK,cAAc,GAAG,CAAC,CAAC,EAAE;IACjD,IAAI,CAACzK,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACyK,cAAc,GAAGA,cAAc;IACpC,KAAK,MAAM,CAACrN,IAAI,EAAEsN,EAAE,CAAC,IAAI3N,MAAM,CAAC4N,OAAO,CAACpN,aAAa,CAAC,EAAE;MACtDR,MAAM,CAACC,cAAc,CAAC,IAAI,EAAEI,IAAI,EAAE;QAChCE,UAAU,EAAE,KAAK;QACjBgE,KAAK,EAAEA,CAACsJ,MAAM,EAAE3K,OAAO;QACrB;QACAyK,EAAE,CAAC;UAAE,GAAGE,MAAM;UAAE5K;QAAY,CAAC,EAAE;UAAE,GAAGyK,cAAc;UAAE,GAAGxK;QAAQ,CAAC;MAEpE,CAAC,CAAC;IACJ;EACF;EACA;AACF;AACA;EACE4K,QAAQA,CAACC,WAAW,EAAE;IACpB,OAAO,IAAIC,mBAAmB,CAACD,WAAW,EAAE,IAAI,CAAC9K,WAAW,EAAE,IAAI,CAACyK,cAAc,CAAC;EACpF;AACF,CAAC;AACD,IAAIM,mBAAmB,GAAG,MAAM;EAC9BxE,WAAWA,CAACuE,WAAW,EAAE9K,WAAW,GAAG,EAAE,EAAEyK,cAAc,GAAG,CAAC,CAAC,EAAE;IAC9DzK,WAAW;IACXyK,cAAc;IACd,KAAK,MAAM,CAACrN,IAAI,EAAEsN,EAAE,CAAC,IAAI3N,MAAM,CAAC4N,OAAO,CAACpN,aAAa,CAAC,EAAE;MACtDR,MAAM,CAACC,cAAc,CAAC,IAAI,EAAEI,IAAI,EAAE;QAChCE,UAAU,EAAE,KAAK;QACjBgE,KAAK,EAAEA,CAACsJ,MAAM,EAAE3K,OAAO;QACrB;QACAyK,EAAE,CAAC;UAAE,GAAGE,MAAM;UAAE5K,WAAW;UAAED,KAAK,EAAE+K;QAAY,CAAC,EAAE;UAAE,GAAGL,cAAc;UAAE,GAAGxK;QAAQ,CAAC;MAExF,CAAC,CAAC;IACJ;EACF;AACF,CAAC;AACD,SACEuK,WAAW,EACXO,mBAAmB,EACnB1E,oBAAoB,EACpB7I,mBAAmB,EACnBC,YAAY,EACZC,0BAA0B,EAC1BC,yBAAyB,EACzBC,iBAAiB,EACjBC,QAAQ,EACRC,mBAAmB,EACnBC,iBAAiB,EACjBC,YAAY,EACZC,WAAW,EACXC,eAAe,EACfC,iBAAiB,EACjBC,OAAO,EACPC,kBAAkB,EAClBC,gBAAgB,EAChBC,aAAa,EACbC,sBAAsB,EACtBC,qBAAqB,EACrBC,iBAAiB,EACjBC,kBAAkB,EAClBC,cAAc,EACdC,oBAAoB,EACpBC,WAAW,EACXC,YAAY,EACZC,mBAAmB,EACnBC,WAAW,EACXC,uBAAuB,EACvBC,sBAAsB,EACtBC,2BAA2B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}